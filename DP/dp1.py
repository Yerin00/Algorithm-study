# 다이나믹 프로그래밍
'''
1. 큰 문제를 작은 무제로 나눌수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

완전 탐색으로 접근했을때 시간이 매우 오래 걸리면 부분 문제들의 중복여부를 확인하여 DP를 적용할 수 있는지 확인한다.

메모리를 약간만 더 사용하여 실행시간을 크게 줄일 수 있는 방법

- 탑다운 vs 보텀업
탑다운(메모제이션, 하향식): 큰 문제를 해결하기 위해 작은 문제를 호출한다.
★보텀업(상향식): 반복문을 이용하여 작은 문제부터 차근차근 답을 도출한다.
'''

## 8-1.py 피보나치 함수___________________________________
'''
O(2^N), 이미 계산한게 반복적으로 또 계산됨. 효율적이지 않음
'''
def fibo(x):
  if x == 1 or x == 2:
    return 1
  return fibo(x - 1) + fibo(x - 2)

print("피보나치함수:",fibo(4))

## 8-2.py 피보나치 수열 소스코드(재귀적)____________________
'''
메모이제이션(Memoization)
'''
d = [0] * 100

def fibo(x):
  # 종료조건
  if x == 1 or x == 2:
    return 1
  # 이미 계산한 적 있는 문제라면 그대로 반환
  if d[x] != 0:
    return d[x]
  # 아직 계산한 적 없는 문제라면 피보나치 점화식 결과 반환
  d[x] = fibo(x - 1) + fibo(x - 2)
  return d[x]

print("재귀적:",fibo(99))

## 8-3.py 호출되는 함수 확인
d = [0] * 100

def pibo(x):
  print('f(' + str(x) + ')', end=' ')
  if x == 1 or x == 2:
    return 1
  if d[x] != 0:
    return d[x]
  d[x] = pibo(x - 1) + pibo(x - 2)
  return d[x]

pibo(6)

## 8-4.py 피보나치 수열 소스코드(반복적)_______________________
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
  d[i] = d[i - 1] + d[i - 2]

print(d[n])